<cfcomponent hint="I am an abstract component for encoding passwords for storage and comparing passwords against previously encoded strings">

	<!--- Array of Java class paths required for this component. Leave empty if no special Java libraries are needed. --->
	<cfset variables.loadPaths = [] />
	
	<cffunction name="init" access="public" output="true" returntype="any" hint="constructor">
		
		<cfset var stMetadata = getMetadata(this) />
		<cfset var attr = "" />
		
		<cfloop condition="not structisempty(stMetadata)">
			<!--- Get attributes --->
			<cfloop collection="#stMetadata#" item="attr">
				<cfif issimplevalue(stMetadata[attr]) and not listcontains("bindingname,extends,fullname,functions,hint,name,namespace,output,path,porttypename,serviceportname,style,type,wsdlfile",attr) and not structkeyexists(this,attr)>
					<cfset this[attr] = stMetadata[attr] />
				</cfif>
			</cfloop>
			
			<!--- Do the same for ancestors --->
			<cfif structkeyexists(stMetadata,"extends")>
				<cfset stMetadata = stMetadata.extends />
			<cfelse>
				<cfset stMetadata = structnew() />
			</cfif>
		</cfloop>
		
		<cfset stMetadata = getMetadata(this) />
		
		<!--- If key isn't specified, use the name of the component --->
		<cfif not structkeyexists(this,"alias")>
			<cfset this.alias = listlast(stMetadata.name,".") />
		</cfif>
		
		<!--- If title isn't specified, use the displayname --->
		<cfif not structkeyexists(this,"title")>
			<cfset this.title = this.displayname />
		</cfif>
		
		<!--- If seq isn't specified, use 9999 --->
		<cfif not structkeyexists(this,"seq")>
			<cfset this.seq = 9999 />
		</cfif>
		
		<cfreturn this />
	</cffunction>

	<cffunction name="isAvailable" hint="Is the hashing agorithm available in this environment?" access="public" returntype="boolean">
		<cfreturn true />
	</cffunction>

	<cffunction name="matchesHashFormat" hint="Does the string match the format for this hash?" access="public" returntype="boolean">
		<cfargument name="input" type="string" required="true" hint="String that may be an encoding of a password" />
		
		<cfthrow message="The #this.alias# password encoding needs to implement the matchesHashFormat function" />
		<cfreturn "" />
	</cffunction>

	<cffunction name="encode" hint="Convert a clear password to its encoded value" access="public" returntype="string">
		<cfargument name="password" type="string" required="true" hint="Input password" />
		
		<cfthrow message="The #this.alias# password encoding needs to implement the encode function" />
		<cfreturn "" />
	</cffunction>

	<cffunction name="passwordMatch" hint="Compare a plain password against an encoded string" access="public" returntype="boolean">
		<cfargument name="password" type="string" required="true" hint="Input password" />
		<cfargument name="hashedPassword" type="string" required="true" hint="Previously encoded password string" />
		<cfargument name="bCheckHashStrength" type="string" default="false" hint="If true, the hash strength of the hashed password must also match those generated by encode()" />
		
		<cfthrow message="The #this.alias# password encoding needs to implement the passwordMatch function" />
		<cfreturn false />
	</cffunction>

	<!--- Private Java library helper functions --->

	<cffunction access="private" name="getJavaLoader" returntype="any" output="false">
		
		<!--- Lazy-loading the JavaLoader makes it easier for plugins/projects to add custom crypto libraries --->
		<cfif not structKeyExists(variables,"loader")>
			<cfset variables.loader = createObject("component", "farcry.core.packages.farcry.javaloader.JavaLoader"
														).init(variables.loadPaths) />
		</cfif>
		<cfreturn variables.loader />
	</cffunction>

	<cffunction access="private" name="createJavaClass" returntype="any" output="false" hint="Return a java class from the crypto libraries">
		<cfargument name="className" type="string" required="true" />
		
		<cfreturn getJavaLoader().create(arguments.className) />
	</cffunction>

</cfcomponent>